<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Multi-Platform Post Splitter Pro</title>
<meta content="Advanced text splitter for all social media platforms with character limits, history, and backup." name="description"/>
<meta content="text splitter, post splitter, character limit, social media, Twitter, Facebook, Instagram, LinkedIn, Threads, GitHub, long post, backup, restore, dark mode, responsive, Pakistan" name="keywords"/>
<meta content="Yasin Ullah, Pakistan" name="author"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet"/>
<style>
        :root {
            --primary-color: #0077b5;
            --primary-hover: #005e91;
            --secondary-color: #eef3f8;
            --font-color: #191919;
            --border-color: #ddd;
            --bg-color: #fff;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --font-family: Calibri, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --primary-color: #0a84c1;
            --primary-hover: #0d99dc;
            --secondary-color: #1d2226;
            --font-color: #e1e1e1;
            --border-color: #444;
            --bg-color: #2a3035;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--font-color);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 800px;
            width: 100%;
            background-color: var(--bg-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        header h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 24px;
        }

        textarea {
            width: 100%;
            height: 250px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--font-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        textarea.rtl {
            direction: rtl;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            align-items: center;
            margin-top: 15px;
            margin-bottom: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }

        .control-group select,
        .control-group input[type="number"],
        .control-group input[type="text"] {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-color);
            color: var(--font-color);
            width: 100%;
            box-sizing: border-box;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .control-group input[type="text"] {
            cursor: text;
        }

        #charCount {
            font-size: 14px;
            background-color: var(--secondary-color);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: 500;
        }

        .main-buttons {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1;
        }

        .btn {
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
            flex-grow: 1;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:active {
            transform: scale(0.98);
        }

        #splitBtn {
            background-color: var(--primary-color);
        }

        #splitBtn:hover {
            background-color: var(--primary-hover);
        }

        #clearBtn {
            background-color: var(--danger-color);
        }

        #clearBtn:hover {
            background-color: #c82333;
        }

        .utility-buttons {
            display: flex;
            gap: 10px;
            grid-column: 1 / -1;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .utility-buttons .btn {
            background-color: #6c757d;
        }

        .utility-buttons .btn:hover {
            background-color: #5a6268;
        }

        #output {
            margin-top: 20px;
        }

        .part-container {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .part-title {
            font-weight: bold;
            color: var(--primary-color);
        }

        .part-char-count {
            font-size: 0.9em;
            color: #777;
        }

        html.dark-mode .part-char-count {
            color: #aaa;
        }

        .copy-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .copy-btn:hover {
            background-color: #5a6268;
        }

        .copy-btn.copied {
            background-color: var(--success-color);
        }

        .part-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 16px;
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 6px;
            min-height: 50px;
        }

        .part-content.rtl {
            direction: rtl;
            text-align: right;
            font-family: Calibri, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: large;
        }

        #copyAllBtn {
            display: block;
            width: 100%;
            background-color: var(--success-color);
            margin-bottom: 20px;
        }

        #themeToggle {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
        }

        .modal-content {
            background-color: var(--bg-color);
            margin: 5% auto;
            padding: 25px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        #historyFilters,
        #backupRestoreSection {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 600px) {

            #historyFilters,
            #backupRestoreSection {
                grid-template-columns: 1fr 1fr;
            }
        }

        #backupRestoreSection {
            grid-template-columns: 1fr 1fr;
        }

        #backupRestoreSection button {
            width: 100%;
        }

        .history-list {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        .history-item {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .history-info p {
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        .history-info .date {
            font-size: 0.9em;
            color: #777;
        }

        html.dark-mode .history-info .date {
            color: #aaa;
        }

        .history-actions {
            display: flex;
            gap: 10px;
        }

        .history-actions .btn {
            padding: 8px 12px;
            font-size: 14px;
        }

        #no-history-msg {
            text-align: center;
            color: #888;
            padding: 40px;
        }

        .toast-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .toast-message.show {
            opacity: 1;
            visibility: visible;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 2s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
            display: none;
        }

        .loader.active {
            display: inline-block;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
<link href="manifest.json" rel="manifest"/>
<link href="favicon.ico" rel="icon" type="image/x-icon"/></head>
<body>
<div class="container">
<header>
<h1>Multi-Platform Post Splitter Pro</h1>
<button aria-label="Toggle dark mode" id="themeToggle">🌙</button>
</header>
<main>
<textarea aria-label="Text input for splitting" id="textInput" placeholder="Paste your long text here. Your draft is saved automatically..."></textarea>
<div class="controls">
<div class="control-group">
<label for="platformSelect">Platform</label>
<select aria-label="Select social media platform" id="platformSelect">
<option value="custom">Custom Limit</option>
<option value="twitter">X (Twitter) - 280</option>
<option value="facebook">Facebook - 63,206</option>
<option value="instagram">Instagram - 2,200</option>
<option value="linkedin">LinkedIn - 3,000</option>
<option value="threads">Threads - 500</option>
<option value="github">GitHub - (Recommended: 3,000)</option>
</select>
</div>
<div class="control-group">
<label for="limitInput">Character Limit</label>
<input aria-label="Character limit per part" id="limitInput" min="0" type="number" value="3000"/>
</div>
<div class="control-group">
<label for="separatorInput">Part Separator (e.g., #/#)</label>
<input aria-label="Separator format for parts" id="separatorInput" placeholder="(#/#)" type="text" value="(#/#)"/>
</div>
<div class="control-group">
<label for="prefixInput">Part Prefix (Optional)</label>
<input aria-label="Optional prefix for each part" id="prefixInput" placeholder="e.g., [Part]" type="text" value=""/>
</div>
<div class="control-group">
<label for="suffixInput">Part Suffix (Optional)</label>
<input aria-label="Optional suffix for each part" id="suffixInput" placeholder="e.g., (Read more)" type="text" value=""/>
</div>
<div class="control-group" id="charCount">Characters: 0 / 3000</div>
</div>
<div class="main-buttons">
<button aria-label="Split text" class="btn" id="splitBtn"><i class="fas fa-cut"></i> Split Text <span class="loader" id="splitLoader"></span></button>
<button aria-label="Clear text area" class="btn" id="clearBtn"><i class="fas fa-eraser"></i>
                    Clear</button>
</div>
<div class="utility-buttons">
<button aria-label="View splitting history" class="btn" id="historyBtn"><i class="fas fa-history"></i>
                    View History</button>
<button aria-label="Backup application data" class="btn" id="backupBtn"><i class="fas fa-download"></i>
                    Backup Data</button>
<input accept=".json" aria-label="Input for restoring data" id="restoreInput" style="display: none;" type="file"/>
<button aria-label="Restore application data from file" class="btn" id="restoreBtn"><i class="fas fa-upload"></i> Restore Data</button>
</div>
<div id="output"></div>
</main>
</div>
<div aria-labelledby="historyModalTitle" aria-modal="true" class="modal" id="historyModal" role="dialog">
<div class="modal-content">
<div class="modal-header">
<h2 id="historyModalTitle">Saved History</h2>
<span aria-label="Close history modal" class="close-btn" id="closeHistoryModal">×</span>
</div>
<div id="historyFilters">
<input aria-label="Search history by content" id="historySearchInput" placeholder="Search in content..." type="search"/>
<input aria-label="Filter history by date" id="historyDateFilter" type="date"/>
</div>
<div aria-label="List of historical split texts" class="history-list" id="historyList" role="region" tabindex="0">
</div>
</div>
</div>
<div aria-live="polite" class="toast-message" id="toastMessage" role="status"></div>
<script>
        const DOM = {
            textInput: document.getElementById('textInput'),
            splitBtn: document.getElementById('splitBtn'),
            clearBtn: document.getElementById('clearBtn'),
            historyBtn: document.getElementById('historyBtn'),
            charCountEl: document.getElementById('charCount'),
            outputEl: document.getElementById('output'),
            limitInput: document.getElementById('limitInput'),
            platformSelect: document.getElementById('platformSelect'),
            separatorInput: document.getElementById('separatorInput'),
            prefixInput: document.getElementById('prefixInput'),
            suffixInput: document.getElementById('suffixInput'),
            themeToggle: document.getElementById('themeToggle'),
            historyModal: document.getElementById('historyModal'),
            closeHistoryModal: document.getElementById('closeHistoryModal'),
            historyListEl: document.getElementById('historyList'),
            historySearchInput: document.getElementById('historySearchInput'),
            historyDateFilter: document.getElementById('historyDateFilter'),
            backupBtn: document.getElementById('backupBtn'),
            restoreInput: document.getElementById('restoreInput'),
            restoreBtn: document.getElementById('restoreBtn'),
            toastMessageEl: document.getElementById('toastMessage'),
            splitLoader: document.getElementById('splitLoader')
        };

        let db;
        const DB_NAME = 'PostSplitterDB_v4';
        const DRAFT_STORE = 'drafts';
        const HISTORY_STORE = 'history';
        const SETTINGS_STORE = 'settings';
        const DRAFT_KEY = 'currentDraft';
        const SETTINGS_KEY = 'userSettings';

        const PLATFORM_LIMITS = {
            custom: { limit: 3000, smartSplit: true },
            twitter: { limit: 280, smartSplit: false },
            facebook: { limit: 63206, smartSplit: true },
            instagram: { limit: 2200, smartSplit: true },
            linkedin: { limit: 3000, smartSplit: true },
            threads: { limit: 500, smartSplit: false },
            github: { limit: 3000, smartSplit: true }
        };

        let lastSavedHistoryEntry = null;

        const showToast = (message, duration = 3000) => {
            DOM.toastMessageEl.textContent = message;
            DOM.toastMessageEl.classList.add('show');
            setTimeout(() => {
                DOM.toastMessageEl.classList.remove('show');
            }, duration);
        };

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, delay);
            };
        };

        const isRtl = (text) => /[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFC]/.test(text);

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 4);
                request.onerror = (e) => {
                    showToast("Database error: " + e.target.errorCode, 5000);
                    reject(e.target.error);
                };
                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(DRAFT_STORE)) {
                        db.createObjectStore(DRAFT_STORE, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(HISTORY_STORE)) {
                        db.createObjectStore(HISTORY_STORE, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                        db.createObjectStore(SETTINGS_STORE, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveToDB(storeName, key, data) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("Database not ready.");
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put({ id: key, ...data });
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function getFromDB(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("Database not ready.");
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveHistoryEntry(entry) {
            // Prevent saving identical entries
            if (lastSavedHistoryEntry &&
                lastSavedHistoryEntry.originalText === entry.originalText &&
                lastSavedHistoryEntry.limit === entry.limit &&
                lastSavedHistoryEntry.platform === entry.platform &&
                lastSavedHistoryEntry.separator === entry.separator &&
                lastSavedHistoryEntry.prefix === entry.prefix &&
                lastSavedHistoryEntry.suffix === entry.suffix &&
                JSON.stringify(lastSavedHistoryEntry.parts) === JSON.stringify(entry.parts)) {
                showToast("No changes to save to history.", 2000);
                return;
            }

            try {
                await saveToDB(HISTORY_STORE, entry.id, entry);
                lastSavedHistoryEntry = entry;
                showToast("Text saved to history!", 2000);
            } catch (error) {
                showToast("Failed to save history: " + error, 3000);
            }
        }

        async function loadAllHistory() {
            return new Promise((resolve, reject) => {
                if (!db) return reject("Database not ready to load history.");
                const transaction = db.transaction([HISTORY_STORE], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result.sort((a, b) => b.id - a.id));
                request.onerror = (e) => reject(e.target.error);
            });
        }

        async function deleteHistoryEntry(id) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("Database not ready to delete history.");
                const transaction = db.transaction([HISTORY_STORE], 'readwrite');
                const request = transaction.objectStore(HISTORY_STORE).delete(id);
                request.onsuccess = () => {
                    showToast("History entry deleted.", 2000);
                    resolve();
                };
                request.onerror = (e) => reject(e.target.error);
            });
        }

        const saveDraftToDB = debounce(async (text) => {
            try {
                if (db) await saveToDB(DRAFT_STORE, DRAFT_KEY, { content: text });
            } catch (error) {
                console.error("Draft save failed:", error);
            }
        }, 500);

        const saveSettingsToDB = debounce(async () => {
            const settings = {
                platform: DOM.platformSelect.value,
                limit: parseInt(DOM.limitInput.value, 10),
                separator: DOM.separatorInput.value,
                prefix: DOM.prefixInput.value,
                suffix: DOM.suffixInput.value,
                theme: localStorage.getItem('theme') || 'light'
            };
            try {
                if (db) await saveToDB(SETTINGS_STORE, SETTINGS_KEY, settings);
            } catch (error) {
                console.error("Settings save failed:", error);
            }
        }, 300);

        async function loadSettingsAndDraftFromDB() {
            try {
                const draft = await getFromDB(DRAFT_STORE, DRAFT_KEY);
                if (draft) {
                    DOM.textInput.value = draft.content;
                    updateCharCount();
                    showToast("Draft loaded.", 1500);
                }

                const settings = await getFromDB(SETTINGS_STORE, SETTINGS_KEY);
                if (settings) {
                    DOM.platformSelect.value = settings.platform || 'custom';
                    DOM.limitInput.value = settings.limit || 3000;
                    DOM.separatorInput.value = settings.separator || '( #/# )';
                    DOM.prefixInput.value = settings.prefix || '';
                    DOM.suffixInput.value = settings.suffix || '';

                    if (settings.theme === 'dark') {
                        document.documentElement.classList.add('dark-mode');
                        DOM.themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                    } else {
                        document.documentElement.classList.remove('dark-mode');
                        DOM.themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
                    }
                }
                DOM.platformSelect.dispatchEvent(new Event('change'));
            } catch (error) {
                console.error("Load failed:", error);
                showToast("Failed to load saved data.", 3000);
            }
        }

        let allHistoryItems = [];
        function renderHistoryList(items) {
            DOM.historyListEl.innerHTML = '';
            if (items.length === 0) {
                DOM.historyListEl.innerHTML = `<p id="no-history-msg">No saved history found.</p>`;
                return;
            }
            items.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'history-item';
                const textSnippet = item.originalText.substring(0, 50).replace(/\n/g, ' ') + (item.originalText.length > 50 ? '...' : '');
                itemEl.innerHTML = `
                    <div class="history-info">
                        <p title="${item.originalText}">${textSnippet}</p>
                        <span class="date">${new Date(item.id).toLocaleString()} | ${item.parts.length} parts | Limit: ${item.limit} | Platform: ${item.platform}</span>
                    </div>
                    <div class="history-actions">
                        <button class="btn load-history-btn" data-id="${item.id}" style="background-color: var(--success-color)"><i class="fas fa-upload"></i> Load</button>
                        <button class="btn delete-history-btn" data-id="${item.id}" style="background-color: var(--danger-color)"><i class="fas fa-trash"></i> Delete</button>
                    </div>
                `;
                DOM.historyListEl.appendChild(itemEl);
            });
        }

        function applyHistoryFilters() {
            const searchTerm = DOM.historySearchInput.value.toLowerCase();
            const filterDate = DOM.historyDateFilter.value;

            let filtered = allHistoryItems.filter(item => {
                const textMatch = item.originalText.toLowerCase().includes(searchTerm);
                let dateMatch = true;
                if (filterDate) {
                    const itemDate = new Date(item.id);
                    const selectedDate = new Date(filterDate);
                    dateMatch = itemDate.getFullYear() === selectedDate.getFullYear() &&
                        itemDate.getMonth() === selectedDate.getMonth() &&
                        itemDate.getDate() === selectedDate.getDate();
                }
                return textMatch && dateMatch;
            });
            renderHistoryList(filtered);
        }

        function updateCharCount() {
            const text = DOM.textInput.value;
            const count = text.length;
            const limit = parseInt(DOM.limitInput.value, 10);

            if (isNaN(limit) || limit < 0) {
                DOM.limitInput.value = 0;
                // No toast here as it fires too often during typing
            }

            DOM.charCountEl.textContent = `Characters: ${count} / ${limit}`;
            DOM.charCountEl.style.color = count > limit ? 'var(--danger-color)' : 'inherit';
            DOM.textInput.classList.toggle('rtl', isRtl(text.substring(0, Math.min(text.length, 100))));
            saveDraftToDB(text);
            saveSettingsToDB();
        }

        function findBestSplitPoint(slice, minLengthPercentage = 0.7) {
            const breakPoints = ['\n\n', '\n', '. ', '! ', '? '];
            let bestPos = -1;

            for (const bp of breakPoints) {
                let pos = slice.lastIndexOf(bp);
                if (pos !== -1 && (pos + bp.length) >= (slice.length * minLengthPercentage)) {
                    return pos + bp.length;
                }
            }

            let pos = slice.lastIndexOf(' ');
            if (pos !== -1 && (pos + 1) >= (slice.length * minLengthPercentage)) {
                return pos + 1;
            }

            return -1;
        }

        const splitText = (fullText, limit, smartSplit, separatorTemplate, partPrefix, partSuffix) => {
            const rawPartsContent = [];
            let remainingText = fullText;

            // Calculate overhead that will be added to each part
            const getOverheadLength = (totalParts) => {
                const tempSeparator = separatorTemplate.includes('#/#') ? separatorTemplate.replace('#/#', `1/${totalParts}`) : separatorTemplate;
                return partPrefix.length + tempSeparator.length + partSuffix.length;
            };

            // Estimate initial total parts to accurately calculate separator length early
            let estimatedTotalParts = 1;
            if (fullText.length > 0) {
                // Iteratively refine totalPartsEstimate to get a more accurate overhead
                let currentEstimate = Math.ceil(fullText.length / (limit - getOverheadLength(1)));
                for (let i = 0; i < 5; i++) { // Max 5 iterations for refinement
                    const newEstimate = Math.ceil(fullText.length / (limit - getOverheadLength(currentEstimate)));
                    if (newEstimate === currentEstimate) break;
                    currentEstimate = newEstimate;
                }
                estimatedTotalParts = currentEstimate;
            }

            while (remainingText.length > 0) {
                const overheadLength = getOverheadLength(estimatedTotalParts);
                const effectiveLimit = limit - overheadLength;

                if (effectiveLimit <= 0) {
                    showToast("Character limit is too low for the chosen prefix/suffix/separator. Please increase limit or shorten markers.", 5000);
                    return [];
                }

                if (remainingText.length <= effectiveLimit) {
                    rawPartsContent.push(remainingText);
                    break;
                }

                let slice = remainingText.substring(0, effectiveLimit);
                let splitPos = -1;

                if (smartSplit) {
                    splitPos = findBestSplitPoint(slice, 0.7);
                    if (splitPos === -1 || splitPos > effectiveLimit) {
                        splitPos = effectiveLimit;
                    }
                } else {
                    splitPos = effectiveLimit;
                }

                rawPartsContent.push(remainingText.substring(0, splitPos));
                remainingText = remainingText.substring(splitPos).trimStart();
            }

            const finalTotalParts = rawPartsContent.length;
            return rawPartsContent.map((content, index) => {
                const formattedSeparator = separatorTemplate.includes('#/#') ? separatorTemplate.replace('#/#', `${index + 1}/${finalTotalParts}`) : separatorTemplate;
                return partPrefix + formattedSeparator + content + partSuffix;
            });
        };


        function renderOutput(parts) {
            DOM.outputEl.innerHTML = '';
            if (parts.length === 0) return;

            if (parts.length > 1) {
                const btn = document.createElement('button');
                btn.id = 'copyAllBtn';
                btn.className = 'btn';
                btn.innerHTML = '<i class="fas fa-copy"></i> Copy All Parts';
                DOM.outputEl.appendChild(btn);
            }

            parts.forEach((partText, i) => {
                const cont = document.createElement('div');
                cont.className = 'part-container';
                cont.innerHTML = `
                    <div class="part-header">
                        <span class="part-title">Part ${i + 1}/${parts.length}</span>
                        <span class="part-char-count">Length: ${partText.length}</span>
                    </div>
                    <pre class="part-content ${isRtl(partText) ? 'rtl' : ''}" tabindex="0">${partText}</pre>
                    <div style="text-align: right; margin-top: 10px;">
                        <button class="copy-btn" aria-label="Copy part ${i + 1}"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                `;
                DOM.outputEl.appendChild(cont);
            });
        }

        function copyToClipboard(text, btn) {
            navigator.clipboard.writeText(text).then(() => {
                const originalContent = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.classList.add('copied');
                showToast("Content copied to clipboard!", 1500);
                setTimeout(() => {
                    btn.innerHTML = originalContent;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
                showToast("Failed to copy content. Please check browser permissions.", 3000);
            });
        }

        async function backupData() {
            DOM.backupBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> Backing up...';
            DOM.backupBtn.disabled = true;

            try {
                const allDrafts = await new Promise((resolve, reject) => {
                    const transaction = db.transaction([DRAFT_STORE], 'readonly');
                    transaction.objectStore(DRAFT_STORE).getAll().onsuccess = (e) => resolve(e.target.result);
                    transaction.onerror = (e) => reject(e.target.error);
                });

                const allHistory = await new Promise((resolve, reject) => {
                    const transaction = db.transaction([HISTORY_STORE], 'readonly');
                    transaction.objectStore(HISTORY_STORE).getAll().onsuccess = (e) => resolve(e.target.result);
                    transaction.onerror = (e) => reject(e.target.error);
                });

                const currentSettings = await getFromDB(SETTINGS_STORE, SETTINGS_KEY);

                const data = {
                    drafts: allDrafts,
                    history: allHistory,
                    settings: currentSettings
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `post_splitter_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Backup downloaded successfully!", 2000);
            } catch (error) {
                console.error("Backup failed:", error);
                showToast("Backup failed: " + error.message, 5000);
            } finally {
                DOM.backupBtn.innerHTML = '<i class="fas fa-download"></i> Backup Data';
                DOM.backupBtn.disabled = false;
            }
        }

        function restoreData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            DOM.restoreBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> Restoring...';
            DOM.restoreBtn.disabled = true;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!db) {
                        showToast("Database not ready for restore. Please try again.", 3000);
                        return;
                    }

                    const transaction = db.transaction([DRAFT_STORE, HISTORY_STORE, SETTINGS_STORE], 'readwrite');
                    const draftStore = transaction.objectStore(DRAFT_STORE);
                    const historyStore = transaction.objectStore(HISTORY_STORE);
                    const settingsStore = transaction.objectStore(SETTINGS_STORE);

                    await Promise.all([
                        new Promise(res => draftStore.clear().onsuccess = res),
                        new Promise(res => historyStore.clear().onsuccess = res),
                        new Promise(res => settingsStore.clear().onsuccess = res)
                    ]);

                    if (data.drafts && Array.isArray(data.drafts)) {
                        for (const draft of data.drafts) {
                            await new Promise(res => draftStore.put(draft).onsuccess = res);
                        }
                    }

                    if (data.history && Array.isArray(data.history)) {
                        for (const historyItem of data.history) {
                            await new Promise(res => historyStore.put(historyItem).onsuccess = res);
                        }
                    }

                    if (data.settings) {
                        await new Promise(res => settingsStore.put({ id: SETTINGS_KEY, ...data.settings }).onsuccess = res);
                    }

                    transaction.oncomplete = () => {
                        loadSettingsAndDraftFromDB();
                        showToast("Data restored successfully!", 3000);
                    };
                    transaction.onerror = (e) => {
                        console.error("Restore transaction failed:", e.target.error);
                        showToast("Data restore failed: " + e.target.error, 5000);
                    };

                } catch (error) {
                    console.error("Error parsing or restoring data:", error);
                    showToast("Failed to restore data. Invalid file format or data corruption.", 5000);
                } finally {
                    DOM.restoreBtn.innerHTML = '<i class="fas fa-upload"></i> Restore Data';
                    DOM.restoreBtn.disabled = false;
                    DOM.restoreInput.value = '';
                }
            };
            reader.onerror = (e) => {
                console.error("File read error:", e.target.error);
                showToast("Error reading file: " + e.target.error, 5000);
                DOM.restoreBtn.innerHTML = '<i class="fas fa-upload"></i> Restore Data';
                DOM.restoreBtn.disabled = false;
            };
            reader.readAsText(file);
        }

        // --- Event Listeners ---
        DOM.splitBtn.addEventListener('click', () => {
            const fullText = DOM.textInput.value.trim();
            if (!fullText) {
                showToast('Please enter some text to split.', 2000);
                return;
            }
            let limit = parseInt(DOM.limitInput.value, 10);
            if (isNaN(limit) || limit < 100) {
                showToast("Character limit must be a number and at least 100.", 3000);
                return;
            }

            DOM.splitLoader.classList.add('active');
            DOM.splitBtn.disabled = true;

            setTimeout(async () => {
                const selectedPlatform = DOM.platformSelect.value;
                const platformConfig = PLATFORM_LIMITS[selectedPlatform];
                const smartSplit = platformConfig?.smartSplit ?? true;

                const separator = DOM.separatorInput.value || '( #/# )';
                const prefix = DOM.prefixInput.value || '';
                const suffix = DOM.suffixInput.value || '';

                const parts = splitText(fullText, limit, smartSplit, separator, prefix, suffix);
                if (parts.length > 0) {
                    renderOutput(parts);
                    const historyEntry = {
                        id: Date.now(),
                        originalText: fullText,
                        limit: limit,
                        parts: parts,
                        platform: selectedPlatform,
                        separator: separator,
                        prefix: prefix,
                        suffix: suffix
                    };
                    await saveHistoryEntry(historyEntry);
                }
                DOM.splitLoader.classList.remove('active');
                DOM.splitBtn.disabled = false;
            }, 50);
        });

        DOM.clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the text area and output?')) {
                DOM.textInput.value = '';
                DOM.outputEl.innerHTML = '';
                updateCharCount();
                showToast("Text cleared.", 1500);
            }
        });

        DOM.textInput.addEventListener('input', updateCharCount);
        DOM.limitInput.addEventListener('input', updateCharCount);
        DOM.separatorInput.addEventListener('input', updateCharCount);
        DOM.prefixInput.addEventListener('input', updateCharCount);
        DOM.suffixInput.addEventListener('input', updateCharCount);

        DOM.platformSelect.addEventListener('change', () => {
            const selected = DOM.platformSelect.value;
            const config = PLATFORM_LIMITS[selected];
            if (selected === 'custom') {
                DOM.limitInput.readOnly = false;
            } else {
                DOM.limitInput.readOnly = true;
                DOM.limitInput.value = config.limit;
            }
            updateCharCount();
        });

        DOM.outputEl.addEventListener('click', (e) => {
            const tgt = e.target;
            const btn = tgt.closest('.copy-btn');
            if (btn) {
                copyToClipboard(btn.closest('.part-container').querySelector('.part-content').innerText, btn);
            } else if (tgt.id === 'copyAllBtn' || tgt.closest('#copyAllBtn')) {
                const copyAllBtn = tgt.id === 'copyAllBtn' ? tgt : tgt.closest('#copyAllBtn');
                copyToClipboard(Array.from(DOM.outputEl.querySelectorAll('.part-content')).map(el => el.innerText).join('\n\n---\n\n'), copyAllBtn);
            }
        });

        DOM.themeToggle.addEventListener('click', () => {
            const html = document.documentElement;
            html.classList.toggle('dark-mode');
            const isDark = html.classList.contains('dark-mode');
            DOM.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            saveSettingsToDB();
        });

        DOM.historyBtn.addEventListener('click', async () => {
            DOM.historyBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> Loading...';
            DOM.historyBtn.disabled = true;
            try {
                allHistoryItems = await loadAllHistory();
                applyHistoryFilters();
                DOM.historyModal.style.display = 'block';
            } catch (error) {
                showToast("Error loading history: " + error, 3000);
            } finally {
                DOM.historyBtn.innerHTML = '<i class="fas fa-history"></i> View History';
                DOM.historyBtn.disabled = false;
            }
        });

        DOM.closeHistoryModal.onclick = () => DOM.historyModal.style.display = "none";
        window.onclick = (e) => { if (e.target === DOM.historyModal) DOM.historyModal.style.display = "none"; };

        DOM.historyListEl.addEventListener('click', async e => {
            const tgt = e.target;
            const btn = tgt.closest('.btn');
            if (!btn) return;

            const id = parseInt(btn.dataset.id, 10);
            if (btn.classList.contains('load-history-btn')) {
                const itemToLoad = allHistoryItems.find(item => item.id === id);
                if (itemToLoad) {
                    DOM.textInput.value = itemToLoad.originalText;
                    DOM.limitInput.value = itemToLoad.limit;
                    DOM.separatorInput.value = itemToLoad.separator || '( #/# )';
                    DOM.prefixInput.value = itemToLoad.prefix || '';
                    DOM.suffixInput.value = itemToLoad.suffix || '';

                    const platformKey = Object.keys(PLATFORM_LIMITS).find(key => PLATFORM_LIMITS[key].limit === itemToLoad.limit && PLATFORM_LIMITS[key].smartSplit === PLATFORM_LIMITS[itemToLoad.platform]?.smartSplit) || 'custom';
                    DOM.platformSelect.value = platformKey;
                    DOM.platformSelect.dispatchEvent(new Event('change'));
                    renderOutput(itemToLoad.parts);
                    updateCharCount();
                    DOM.historyModal.style.display = 'none';
                    showToast("History loaded.", 2000);
                }
            } else if (btn.classList.contains('delete-history-btn')) {
                if (confirm('Are you sure you want to delete this entry?')) {
                    try {
                        await deleteHistoryEntry(id);
                        allHistoryItems = allHistoryItems.filter(item => item.id !== id);
                        applyHistoryFilters();
                    } catch (error) {
                        showToast("Error deleting history entry: " + error, 3000);
                    }
                }
            }
        });

        DOM.historySearchInput.addEventListener('input', applyHistoryFilters);
        DOM.historyDateFilter.addEventListener('input', applyHistoryFilters);

        DOM.backupBtn.addEventListener('click', backupData);
        DOM.restoreBtn.addEventListener('click', () => DOM.restoreInput.click());
        DOM.restoreInput.addEventListener('change', restoreData);

        // --- Initializations ---
        document.addEventListener('DOMContentLoaded', async () => {
            await initDB(); // Ensure DB is ready before proceeding

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-mode');
                DOM.themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
            } else {
                DOM.themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
            }

            await loadSettingsAndDraftFromDB();

            // Sample data for initial load - only if history is empty
            const sampleData = [
                {
                    id: 1678886400000,
                    originalText: "This is a comprehensive guide to mastering web development, from HTML to advanced JavaScript frameworks. It covers responsive design principles, backend technologies, and deployment strategies. Learning web development is a continuous journey that requires dedication and practice. Many resources are available online, including tutorials, documentation, and online courses. Don't be afraid to experiment and build projects to solidify your understanding. The web development landscape is constantly evolving, so staying updated with the latest trends and technologies is crucial for success. Consider contributing to open-source projects or participating in coding challenges to enhance your skills. This long text needs to be split for various social media platforms. We'll demonstrate how it works on Twitter, Instagram, and more.",
                    limit: 280,
                    platform: "twitter",
                    separator: "(#/#)",
                    prefix: "",
                    suffix: "",
                    parts: [
                        "(1/5) This is a comprehensive guide to mastering web development, from HTML to advanced JavaScript frameworks. It covers responsive design principles, backend technologies, and deployment strategies. Learning web development is a continuous journey that requires dedication and practice. Many resources are available online",
                        "(2/5) including tutorials, documentation, and online courses. Don't be afraid to experiment and build projects to solidify your understanding. The web development landscape is constantly evolving, so staying updated with the latest trends and technologies is crucial for success.",
                        "(3/5) Consider contributing to open-source projects or participating in coding challenges to enhance your skills. This long text needs to be split for various social media platforms. We'll demonstrate how it works on Twitter, Instagram, and more.",
                        "(4/5) This text is specifically designed to showcase the splitting capabilities, including how it handles sentence endings and paragraph breaks. Ensuring your content is digestible across platforms is key to effective communication. Hopefully, this tool helps.",
                        "(5/5) Final part of the sample text. Always review your split parts before publishing."
                    ]
                },
                {
                    id: 1691372800000,
                    originalText: "پاکستان دنیا میں ایک منفرد مقام رکھتا ہے، اپنی ثقافت، تاریخی ورثے اور دلکش مناظر کی وجہ سے۔ شمالی علاقہ جات کی خوبصورتی، سندھ کی قدیم تہذیب، پنجاب کی زرخیزی اور بلوچستان کی وسعت اسے ایک متنوع ملک بناتی ہے۔ پاکستانی کھانا بھی اپنی لذت اور تنوع کے لیے دنیا بھر میں مشہور ہے، خاص طور پر بریانی، نہاری اور کباب۔ یہ ملک محنت کش اور باصلاحیت لوگوں سے بھرا پڑا ہے جو ہر شعبے میں اپنی خدمات پیش کر رہے ہیں۔ ہمیں اپنے ملک پر فخر ہے اور ہم اس کی ترقی کے لیے پرعزم ہیں۔ تعلیم، صحت اور ٹیکنالوجی کے شعبوں میں مزید ترقی کی ضرورت ہے تاکہ آنے والی نسلوں کا مستقبل روشن ہو۔",
                    limit: 500,
                    platform: "threads",
                    separator: "(#/#)",
                    prefix: "پوسٹ ",
                    suffix: " (جاری ہے)",
                    parts: [
                        "پوسٹ (1/2) پاکستان دنیا میں ایک منفرد مقام رکھتا ہے، اپنی ثقافت، تاریخی ورثے اور دلکش مناظر کی وجہ سے۔ شمالی علاقہ جات کی خوبصورتی، سندھ کی قدیم تہذیب، پنجاب کی زرخیزی اور بلوچستان کی وسعت اسے ایک متنوع ملک بناتی ہے۔ پاکستانی کھانا بھی اپنی لذت اور تنوع کے لیے دنیا بھر میں مشہور ہے، خاص طور پر بریانی، نہاری اور کباب۔ (جاری ہے)",
                        "پوسٹ (2/2) یہ ملک محنت کش اور باصلاحیت لوگوں سے بھرا پڑا ہے جو ہر شعبے میں اپنی خدمات پیش کر رہے ہیں۔ ہمیں اپنے ملک پر فخر ہے اور ہم اس کی ترقی کے لیے پرعزم ہیں۔ تعلیم، صحت اور ٹیکنالوجی کے شعبوں میں مزید ترقی کی ضرورت ہے تاکہ آنے والی نسلوں کا مستقبل روشن ہو۔ (جاری ہے)"
                    ]
                },
                {
                    id: 1704067200000,
                    originalText: "The importance of artificial intelligence in modern business cannot be overstated. AI is transforming industries by automating processes, enhancing decision-making with data-driven insights, and enabling personalized customer experiences. From machine learning algorithms powering recommendation systems to natural language processing in chatbots, AI applications are diverse and growing rapidly. Businesses that adopt AI early gain a significant competitive advantage. However, ethical considerations and data privacy concerns must be addressed responsibly to ensure sustainable AI development. Investment in AI research and talent development is crucial for future innovation and economic growth. This includes developing robust frameworks for AI governance and ensuring fair and transparent AI systems.",
                    limit: 1000,
                    platform: "custom",
                    separator: "(#/#)",
                    prefix: "",
                    suffix: "",
                    parts: [
                        "(1/1) The importance of artificial intelligence in modern business cannot be overstated. AI is transforming industries by automating processes, enhancing decision-making with data-driven insights, and enabling personalized customer experiences. From machine learning algorithms powering recommendation systems to natural language processing in chatbots, AI applications are diverse and growing rapidly. Businesses that adopt AI early gain a significant competitive advantage. However, ethical considerations and data privacy concerns must be addressed responsibly to ensure sustainable AI development. Investment in AI research and talent development is crucial for future innovation and economic growth. This includes developing robust frameworks for AI governance and ensuring fair and transparent AI systems."
                    ]
                },
                {
                    id: 1717027200000,
                    originalText: "Sustainability is key to our planet's future. It encompasses environmental protection, social equity, and economic viability. Implementing sustainable practices in daily life, such as reducing waste, conserving energy, and supporting eco-friendly businesses, can make a significant difference. Governments, corporations, and individuals all have a role to play in achieving a sustainable future. Renewable energy sources, circular economy models, and biodiversity conservation are vital components. Let's work together for a greener and fairer world. Every small effort contributes to a larger impact.",
                    limit: 2200,
                    platform: "instagram",
                    separator: "(#/#)",
                    prefix: "Part ",
                    suffix: " #Sustainability",
                    parts: [
                        "Part (1/1) Sustainability is key to our planet's future. It encompasses environmental protection, social equity, and economic viability. Implementing sustainable practices in daily life, such as reducing waste, conserving energy, and supporting eco-friendly businesses, can make a significant difference. Governments, corporations, and individuals all have a role to play in achieving a sustainable future. Renewable energy sources, circular economy models, and biodiversity conservation are vital components. Let's work together for a greener and fairer world. Every small effort contributes to a larger impact. #Sustainability"
                    ]
                }
            ];

            try {
                const items = await loadAllHistory();
                if (items.length === 0) {
                    const transaction = db.transaction([HISTORY_STORE], 'readwrite');
                    const store = transaction.objectStore(HISTORY_STORE);
                    for (const item of sampleData) {
                        await new Promise(res => store.add(item).onsuccess = res);
                    }
                    showToast("Sample data loaded into history.", 2000);
                }
            } catch (error) {
                console.error("Error checking history for sample data:", error);
            }
        });
    </script>

<script type="module">
  import { Workbox } from 'https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-window.prod.mjs';

  const swUrl = './sw.js';
  const wb = new Workbox(swUrl);

  wb.addEventListener('waiting', () => {
    console.log('A new service worker is waiting to activate.');
    wb.messageSW({ type: 'SKIP_WAITING' });
  });

  wb.addEventListener('controlling', () => {
    console.log('The new service worker is now in control. Reloading page for updates...');
    window.location.reload();
  });

  wb.register();
</script></body>
</html>